/* nexage_exchange_connector.cc
   Jan S.
   (C) 2014 Datacratic Inc

   Implementation of the Nexage exchange connector.

   OpenRTB is fully supported with respect to the win notice and ad
   serving mechanisms. In addition, a default win notice can be
   configured on the Nexage RTB Exchange. This default win notice will
   be used if it is not passed via the “nurl” attribute.

   All substitution macros are supported both in ad markup and in win
   notices (whether passed in the bid response or configured as an
   Exchange default). No macro encoding options are currently
   supported.

   Bidders can provide ad markup in their bid response via the “adm”
   attribute in case they win or on the win notice response when they
   win. Only one method should be used in a given auction, but if
   non-empty strings are found in both, the Nexage RTB Exchange will
   use the bid response “adm” attribute and ignore the win notice
   return body.

   On a given auction if the winning bidder fails to return ad markup
   via one of these two methods, then the win will be forfeited and
   the Exchange will select a new winner.
*/

#include "nexage_exchange_connector.h"
#include "rtbkit/plugins/bid_request/openrtb_bid_request.h"
#include "rtbkit/plugins/exchange/http_auction_handler.h"
#include "rtbkit/core/agent_configuration/agent_config.h"
#include "rtbkit/openrtb/openrtb_parsing.h"
#include "soa/types/json_printing.h"
#include <boost/any.hpp>
#include <boost/lexical_cast.hpp>
#include "jml/utils/file_functions.h"

#include "crypto++/blowfish.h"
#include "crypto++/modes.h"
#include "crypto++/filters.h"

using namespace std;
using namespace Datacratic;

namespace RTBKIT {

/*****************************************************************************/
/* NEXAGE EXCHANGE CONNECTOR                                                */
/*****************************************************************************/

NexageExchangeConnector::
NexageExchangeConnector(ServiceBase & owner, const std::string & name)
    : OpenRTBExchangeConnector(owner, name) {
    this->auctionResource = "/auctions";
    this->auctionVerb = "POST";
}

NexageExchangeConnector::
NexageExchangeConnector(const std::string & name,
                        std::shared_ptr<ServiceProxies> proxies)
    : OpenRTBExchangeConnector(name, proxies) {
    this->auctionResource = "/auctions";
    this->auctionVerb = "POST";
}

ExchangeConnector::ExchangeCompatibility
NexageExchangeConnector::
getCampaignCompatibility(const AgentConfig & config,
                         bool includeReasons) const {
    ExchangeCompatibility result;
    result.setCompatible();

    auto cpinfo = std::make_shared<CampaignInfo>();

    const Json::Value & pconf = config.providerConfig["nexage"];

    try {
        cpinfo->seat = Id(pconf["seat"].asString());
        if (!cpinfo->seat)
            result.setIncompatible("providerConfig.nexage.seat is null",
                                   includeReasons);
    } catch (const std::exception & exc) {
        result.setIncompatible
        (string("providerConfig.nexage.seat parsing error: ")
         + exc.what(), includeReasons);
        return result;
    }

    try {
        cpinfo->iurl = pconf["iurl"].asString();
        if (!cpinfo->iurl.size())
            result.setIncompatible("providerConfig.nexage.iurl is null",
                                   includeReasons);
    } catch (const std::exception & exc) {
        result.setIncompatible
        (string("providerConfig.nexage.iurl parsing error: ")
         + exc.what(), includeReasons);
        return result;
    }

    result.info = cpinfo;

    return result;
}

namespace {

using Datacratic::jsonDecode;

/** Given a configuration field, convert it to the appropriate JSON */
template<typename T>
void getAttr(ExchangeConnector::ExchangeCompatibility & result,
             const Json::Value & config,
             const char * fieldName,
             T & field,
             bool includeReasons) {
    try {
        if (!config.isMember(fieldName)) {
            result.setIncompatible
            ("creative[].providerConfig.nexage." + string(fieldName)
             + " must be specified", includeReasons);
            return;
        }

        const Json::Value & val = config[fieldName];

        jsonDecode(val, field);
    } catch (const std::exception & exc) {
        result.setIncompatible("creative[].providerConfig.nexage."
                               + string(fieldName) + ": error parsing field: "
                               + exc.what(), includeReasons);
        return;
    }
}

} // file scope

ExchangeConnector::ExchangeCompatibility
NexageExchangeConnector::
getCreativeCompatibility(const Creative & creative,
                         bool includeReasons) const {
    ExchangeCompatibility result;
    result.setCompatible();

    auto crinfo = std::make_shared<CreativeInfo>();

    const Json::Value & pconf = creative.providerConfig["nexage"];

    // 1.  Must have creative ID in nexage.crid
    getAttr(result, pconf, "crid", crinfo->crid, includeReasons);
    if (!crinfo->crid)
        result.setIncompatible
        ("creative[].providerConfig.nexage.crid is null",
         includeReasons);


    // 2.  Must have AdvertiserDomain in nexage.crid
    getAttr(result, pconf, "adomain", crinfo->adomain, includeReasons);
    if (crinfo->adomain.empty())
        result.setIncompatible
        ("creative[].providerConfig.nexage.adomain is null",
         includeReasons);


    // 3.  Might have nurl that includes 's macro
    if (pconf.isMember("nurl")) {
        crinfo->nurl = pconf["nurl"].asString();
    }

    // 4.  Might have adm that includes 's macro
    if (pconf.isMember("adm")) {
        crinfo->adm = pconf["adm"].asString();
    }

    // Cache the information
    result.info = crinfo;

    return result;
}
std::shared_ptr<BidRequest>
NexageExchangeConnector::
parseBidRequest(HttpAuctionHandler & connection,
                const HttpHeader & header,
                const std::string & payload) {
    std::shared_ptr<BidRequest> res;
//
    // Check for JSON content-type
    if (header.contentType != "application/json") {
        connection.sendErrorResponse("non-JSON request");
        return res;
    }

#if 0
    /*
     * Unfortunately, x-openrtb-version isn't sent in the real traffic
     */
    // Check for the x-openrtb-version header
    auto it = header.headers.find("x-openrtb-version");
    if (it == header.headers.end()) {
        connection.sendErrorResponse("no OpenRTB version header supplied");
        return res;
    }

    // Check that it's version 2.1
    std::string openRtbVersion = it->second;
    if (openRtbVersion != "2.0") {
        connection.sendErrorResponse("expected OpenRTB version 2.0; got " + openRtbVersion);
        return res;
    }
#endif

    // Parse the bid request
    ML::Parse_Context context("Bid Request", payload.c_str(), payload.size());
    res.reset(OpenRtbBidRequestParser::parseBidRequest(context, exchangeName(), exchangeName()));

    return res;
}


void
NexageExchangeConnector::
setSeatBid(Auction const & auction,
           int spotNum,
           OpenRTB::BidResponse & response) const {

    const Auction::Data * current = auction.getCurrentData();

    // Get the winning bid
    auto & resp = current->winningResponse(spotNum);

    // Find how the agent is configured.  We need to copy some of the
    // fields into the bid.
    const AgentConfig * config =
        std::static_pointer_cast<const AgentConfig>(resp.agentConfig).get();

    std::string en = exchangeName();

    // Get the exchange specific data for this campaign
    auto cpinfo = config->getProviderData<CampaignInfo>(en);

    // Put in the fixed parts from the creative
    int creativeIndex = resp.agentCreativeIndex;

    auto & creative = config->creatives.at(creativeIndex);

    // Get the exchange specific data for this creative
    auto crinfo = creative.getProviderData<CreativeInfo>(en);

    // Find the index in the seats array
    int seatIndex = 0;
    while(response.seatbid.size() != seatIndex) {
        if(response.seatbid[seatIndex].seat == cpinfo->seat) break;
        ++seatIndex;
    }

    // Create if required
    if(seatIndex == response.seatbid.size()) {
        response.seatbid.emplace_back();
        response.seatbid.back().seat = cpinfo->seat;
    }

    // Get the seatBid object
    OpenRTB::SeatBid & seatBid = response.seatbid.at(seatIndex);

    // Add a new bid to the array
    seatBid.bid.emplace_back();
    auto & b = seatBid.bid.back();

    // Put in the variable parts
    b.cid = Id(resp.agent);
    b.iurl = cpinfo->iurl;
    b.impid = auction.request->imp[spotNum].id;
    b.id = Id(auction.id, auction.request->imp[0].id);
    b.price.val = USD_CPM(resp.price.maxPrice);
    b.crid = crinfo->crid;
    b.adomain = crinfo->adomain;
    // optional parts
    if (!crinfo->nurl.empty()) b.nurl = crinfo->nurl;
    if (!crinfo->adm.empty()) b.adm = crinfo->adm;
}

} // namespace RTBKIT

namespace {
using namespace RTBKIT;

struct Init {
    Init() {
        ExchangeConnector::registerFactory<NexageExchangeConnector>();
    }
} init;
}

